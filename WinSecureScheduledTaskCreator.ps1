<#
.SYNOPSIS
This powershell script creates a "secure" scheduled task by only allowing an executable or script to run if it matches a (pre-calculated) SHA256 hash.

.DESCRIPTION

Process;

- This powershell script will 
-- Ask for the name that will be used for the scheduled task 
-- Ask for details of the executable or script to started in a scheduled.  
-- Ask for details of an SMTP server and email options (sender, recipient, subject and body text)
-- Calculate the SHA256 hash of the executable to be run.
-- Generate a scheduled task argument 

- The admin then creates the scheduled task based on the output of the script

- Running the scheduled task will then check that the executable/script to be started still matches the calculated SHA256 hash.  If the executable/script no longer matches the SHA256 hash it will send an email alert. 

.EXAMPLE
./WinSecureScheduledTaskCreator.ps1

This will run the script. If the config file WinSecureScheduledTaskCreator.json is found in the same folder as the script then it will be used otherwise the script will prompt for the required information

.EXAMPLE
./WinSecureScheduledTaskCreator.ps1 -fConfigPath <full path name to WinSecureScheduledTaskCreator.json>

This will run the script using the config file specified in fConfigPath

.NOTES
Use this as you wish but I take no responsibility whatsoever for the outcomes!  Be excellent to each other.

.LINK
https://github.com/MVogwell/ps_Util_WinSecureScheduledTaskCreator

#>

[CmdletBinding()]
param (
	$fConfigPath = ""
)

$ErrorActionPreference = "Stop"

write-host "`n`nSecure Task Scheduler Command Creation" -fore green
write-host "MVogwell - Version 1.0 - 25-10-19`n" -fore green

write-host "This tool will request information from you to generate a command that will secure the execution of applications and scripts by Windows Task Scheduler. Please answer the following questions then follow the instructions to complete.`n`n"

# Info required:
# 	Script / exe path (to get the hash)
#	SHA256 Hash
#	Location of where the script will be run from
# 	SMTP Server
#	Senders address
#	Recipient address
#	FailedExecutionSubject
#	FailedExecutionMessageBody

If ($fConfigPath.Length -eq 0) {
	$fConfigPath = $PSScriptRoot + "\WinSecureScheduledTaskCreator.json"
}

If(!(Test-Path($fConfigPath))) {
	Write-Host "Config file not found. You will be asked for the required details instead... `n" -ForegroundColor Yellow

	$objSettings = $Null
}
Else {
	$bSettingsFileParsed = $True

	Try {
		Write-Host "JSON config file path: $fConfigPath" -ForegroundColor Yellow

		Write-Host "Attempting to parse the config file" -ForegroundColor Yellow
		$objSettings = Get-content($fConfigPath) | Out-String | ConvertFrom-Json
		write-host "... Successfully parsed`n" -fore Green
	}
	Catch {
		$objSettings = $Null
		$sErrMsg = ($Error[0].Exception.Message).replace("`r"," ").replace("`n"," ")
		write-host "... Unable to parse settings file. Please check the formatting. `n" -ForegroundColor Red
		Write-Host "... The script will now continue but will ask for the required settings. `n`n" -ForegroundColor Red
	}
}

If ($bSettingsFileParsed -eq $True) {
	# Set the path of Powershell - this is used in the scheduled task that is generated by this script
	# Attempt to get the path from the config file but if this is unavailable set it to the standard path
	Try {
		$sPowershell = $objSettings.PowershellPath
	}
	Catch {
		$sPowershell = "%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe"
	}

	# Get the name of the scheduled task (this is for email alerts only)
	Do {
		$sSchedTaskName = read-host "Enter the name that you will use for the scheduled task"
	}
	While($sPath.Length -eq 0)

	write-host "`nEnter the full path to the executable/script that will be run by the scheduled task" -ForegroundColor Yellow
	write-host "...(must be accessible but doesn't have to be in the final destination)" -ForegroundColor Yellow

	# Until a non-zero length sting is returned keep asking for the path
	Do {
		$sPath = Read-Host "Executable/Script Path"
	}
	While($sPath.Length -eq 0)

	# Remove any inverted commas from the path
	$sPath = $sPath.replace("""","")

	# Check that the path to the executable exists
	If (Test-Path($sPath)) {
		# Get the SHA256 hash of the file to execute in the scheduled task
		$bGetHashSuccess = $True	# Used to define whether the hash was created successfully
		Try {
			# Attempt to get the sha256 hash of the file
			$sSHA256Hash = ([System.BitConverter]::ToString((New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider).ComputeHash([System.IO.File]::ReadAllBytes($sPath))))

			Write-Verbose "Successfully extracted the SHA256 hash of the file to execute in the scheduled task"
		}
		Catch {
			$bGetHashSuccess = $False

			# Exit script with error
			Write-Host "`nFailed to extract the SHA256 hash of the executable/script`n" -ForegroundColor Red

			$sErrMsg = ($Error[0].Exception.Message).replace("`r"," ").replace("`n"," ")
			Write-Host "It was not possible to extract the SHA256 hash from the file specified. Error message: $sErrMsg `n" -ForegroundColor Red
			Write-Host "The script will now exit!" -ForegroundColor Red
		}

		# Continue if there was no error getting the hash from the file to execute
		If ($bGetHashSuccess -eq $True) {
			write-host "`n"

			# Get the path of where the executable will be stored on the server.
			# This is used in the scheduled task argument to start the executable
			Do {
				$sAppScriptExecutionPath = read-host "Enter the path where the script/exe will be located on the server running the scheduled task"
				$sAppScriptExecutionPath = $sAppScriptExecutionPath.replace("""","")
			}
			While($sAppScriptExecutionPath.Length -le 3)

			# Get the SMTP server setting if not found in the config file
			Try { 
				$sSMTPServer = $objSettings.sSMTPServer 
				If ($Null -eq $sSMTPServer) { Throw "Value not set"}
			}
			Catch {
				write-host "`n"

				Do {
					$sSMTPServer = read-host "Enter the DNS name or IP of the SMTP server"
				}
				While($sSMTPServer.Length -eq 0)
			}

			# Get the sender SMTP address if not specified in the config file
			Try { 
				$sSender = $objSettings.sSender 
				If ($Null -eq $sSender) { Throw "Value not set"}
			}
			Catch {
				write-host "`n"

				Do {
					$sSender = read-host "Enter the email address of the sender"
				}
				While($sSender.Length -eq 0)
			}

			# Get the recipient name from the config file. If the setting can't be found ask for it.
			Try { 
				$sRecipient = $objSettings.sRecipient 
				If ($Null -eq $sRecipient) { Throw "Value not set"}
			}
			Catch {
				Write-Host "`n"

				Do {
					$sRecipient = read-host "Enter the email address of the recipient"
				}
				While($sRecipient.Length -eq 0)
			}

			# Get the email subject from the config file. If the setting can't be found ask for it.
			Try {
				$sSubject = $objSettings.sSubject
				If ($Null -eq $sSubject) { Throw "Value not set"}
			}
			Catch {
				Write-Host "`n"

				Do {
					$sSubject = read-host "Enter the subject for the email (e.g. Failed to Run Scheduled Script)"
				}
				While($sSubject.Length -eq 0)
			}

			# Create the full subject line including the message from the config/user input, the server name and the task name
			$sSubject = "'" + $sSubject + " :: Servername: ' + `$sServerName + ' :: TaskName: " + $sSchedTaskName + "'"

			Try {
				$sMsgBodyText = $objSettings.sMsgBody
				If ($Null -eq $sMsgBodyText) { Throw "Value not set"}
			}
			Catch {
				write-host "`n"

				Do {
					$sMsgBodyText = read-host "Enter the message body text for the email (e.g. Failed to Run Scheduled Script because the SHA256 hash does not match)"
				}
				While($sMsgBodyText.Length -eq 0)
			}

			$sMsgBody ="'<HTML><HEAD></HEAD>" 
			$sMsgBody += $sMsgBodyText + "<br>"
			$sMsgBody += "Servername: ' + `$sServerName + ' <br>"
			$sMsgBody += "Scheduled Task Name: " + $sSchedTaskName + " <br>"
			$sMsgBody += "Path: " + $sAppScriptExecutionPath + " <br>"
			$sMsgBody += "<BODY></BODY></HTML>'"

			# Display the file hash information if verbose is selected
			Write-Verbose "Executable/Script Path: $sPath"
			Write-Verbose "SHA256 Hash: $sSHA256Hash `n"

			# Create the string that will form the argument for the scheduled task
			$sCmd = "-command `$sServerName = `$Env:ComputerName ; `$sSubject = " + $sSubject + " ; `$sMsgBody = " + $sMsgBody + " ; If ([System.BitConverter]::ToString((New-Object -TypeName System.Security.Cryptography.SHA256CryptoServiceProvider).ComputeHash([System.IO.File]::ReadAllBytes('" + $sAppScriptExecutionPath + "'))) -eq '" + $sSHA256Hash + "') { . '" + $sAppScriptExecutionPath + "'} Else { Send-MailMessage -SmtpServer " + $sSMTPServer + " -BodyAsHtml -From " + $sSender + " -To " + $sRecipient + " -Subject `$sSubject -Body `$sMsgBody }"

			write-host "`nBased on your answers... `n" -ForegroundColor Yellow
			write-host "Create a new scheduled task on the destination server called - $sSchedTaskName - and then paste the following into the Program/Script section (this has been copied to clipboard for you): `n" -ForegroundColor Yellow

			write-host "$sPowershell" -fore cyan
			$sPowershell | clip

			write-host "`nPress any key to continue...`n" -NoNewline
			$host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown") | Out-Null

			write-host "`nAnd now in the Arguments section paste in the following (copied to clipboard for you) `n" -ForegroundColor Yellow
			write-host "$sCmd" -fore cyan
			$sCmd | clip

			write-host "`nFinished! `n`n"
		}
	}
	Else {
		write-host "`n`nThe path you entered for the executable does not exist. Please re-run this script and try again`n" -fore red -back white
	}
}

